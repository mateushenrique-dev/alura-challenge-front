{"ast":null,"code":"/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n  return re.source;\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\n\n\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\n\n\nfunction concat(...args) {\n  const joined = args.map(x => source(x)).join(\"\");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\n\n\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = '(' + (opts.capture ? \"\" : \"?:\") + args.map(x => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n/*\nLanguage: Wren\nDescription: Think Smalltalk in a Lua-sized package with a dash of Erlang and wrapped up in a familiar, modern syntax.\nCategory: scripting\nAuthor: @joshgoebel\nMaintainer: @joshgoebel\nWebsite: https://wren.io/\n*/\n\n/** @type LanguageFn */\n\n\nfunction wren(hljs) {\n  const IDENT_RE = /[a-zA-Z]\\w*/;\n  const KEYWORDS = [\"as\", \"break\", \"class\", \"construct\", \"continue\", \"else\", \"for\", \"foreign\", \"if\", \"import\", \"in\", \"is\", \"return\", \"static\", \"var\", \"while\"];\n  const LITERALS = [\"true\", \"false\", \"null\"];\n  const LANGUAGE_VARS = [\"this\", \"super\"];\n  const CORE_CLASSES = [\"Bool\", \"Class\", \"Fiber\", \"Fn\", \"List\", \"Map\", \"Null\", \"Num\", \"Object\", \"Range\", \"Sequence\", \"String\", \"System\"];\n  const OPERATORS = [\"-\", \"~\", /\\*/, \"%\", /\\.\\.\\./, /\\.\\./, /\\+/, \"<<\", \">>\", \">=\", \"<=\", \"<\", \">\", /\\^/, /!=/, /!/, /\\bis\\b/, \"==\", \"&&\", \"&\", /\\|\\|/, /\\|/, /\\?:/, \"=\"];\n  const FUNCTION = {\n    relevance: 0,\n    match: concat(/\\b(?!(if|while|for|else|super)\\b)/, IDENT_RE, /(?=\\s*[({])/),\n    className: \"title.function\"\n  };\n  const FUNCTION_DEFINITION = {\n    match: concat(either(concat(/\\b(?!(if|while|for|else|super)\\b)/, IDENT_RE), either(...OPERATORS)), /(?=\\s*\\([^)]+\\)\\s*\\{)/),\n    className: \"title.function\",\n    starts: {\n      contains: [{\n        begin: /\\(/,\n        end: /\\)/,\n        contains: [{\n          relevance: 0,\n          scope: \"params\",\n          match: IDENT_RE\n        }]\n      }]\n    }\n  };\n  const CLASS_DEFINITION = {\n    variants: [{\n      match: [/class\\s+/, IDENT_RE, /\\s+is\\s+/, IDENT_RE]\n    }, {\n      match: [/class\\s+/, IDENT_RE]\n    }],\n    scope: {\n      2: \"title.class\",\n      4: \"title.class.inherited\"\n    },\n    keywords: KEYWORDS\n  };\n  const OPERATOR = {\n    relevance: 0,\n    match: either(...OPERATORS),\n    className: \"operator\"\n  };\n  const TRIPLE_STRING = {\n    className: \"string\",\n    begin: /\"\"\"/,\n    end: /\"\"\"/\n  };\n  const PROPERTY = {\n    className: \"property\",\n    begin: concat(/\\./, lookahead(IDENT_RE)),\n    end: IDENT_RE,\n    excludeBegin: true,\n    relevance: 0\n  };\n  const FIELD = {\n    relevance: 0,\n    match: concat(/\\b_/, IDENT_RE),\n    scope: \"variable\"\n  }; // CamelCase\n\n  const CLASS_REFERENCE = {\n    relevance: 0,\n    match: /[A-Z]+[a-z]+([A-Z]+[a-z]+)*/,\n    scope: \"title.class\",\n    keywords: {\n      _: CORE_CLASSES\n    }\n  }; // TODO: add custom number modes\n\n  const NUMBER = hljs.C_NUMBER_MODE;\n  const SETTER = {\n    match: [IDENT_RE, /\\s*/, /=/, /\\s*/, /\\(/, IDENT_RE, /\\)\\s*\\{/],\n    scope: {\n      1: \"title.function\",\n      3: \"operator\",\n      6: \"params\"\n    }\n  };\n  const COMMENT_DOCS = hljs.COMMENT(/\\/\\*\\*/, /\\*\\//, {\n    contains: [{\n      match: /@[a-z]+/,\n      scope: \"doctag\"\n    }, \"self\"]\n  });\n  const SUBST = {\n    scope: \"subst\",\n    begin: /%\\(/,\n    end: /\\)/,\n    contains: [NUMBER, CLASS_REFERENCE, FUNCTION, FIELD, OPERATOR]\n  };\n  const STRING = {\n    scope: \"string\",\n    begin: /\"/,\n    end: /\"/,\n    contains: [SUBST, {\n      scope: \"char.escape\",\n      variants: [{\n        match: /\\\\\\\\|\\\\[\"0%abefnrtv]/\n      }, {\n        match: /\\\\x[0-9A-F]{2}/\n      }, {\n        match: /\\\\u[0-9A-F]{4}/\n      }, {\n        match: /\\\\U[0-9A-F]{8}/\n      }]\n    }]\n  };\n  SUBST.contains.push(STRING);\n  const ALL_KWS = [...KEYWORDS, ...LANGUAGE_VARS, ...LITERALS];\n  const VARIABLE = {\n    relevance: 0,\n    match: concat(\"\\\\b(?!\", ALL_KWS.join(\"|\"), \"\\\\b)\", /[a-zA-Z_]\\w*(?:[?!]|\\b)/),\n    className: \"variable\"\n  }; // TODO: reconsider this in the future\n\n  const ATTRIBUTE = {\n    // scope: \"meta\",\n    scope: \"comment\",\n    variants: [{\n      begin: [/#!?/, /[A-Za-z_]+(?=\\()/],\n      beginScope: {// 2: \"attr\"\n      },\n      keywords: {\n        literal: LITERALS\n      },\n      contains: [// NUMBER,\n        // VARIABLE\n      ],\n      end: /\\)/\n    }, {\n      begin: [/#!?/, /[A-Za-z_]+/],\n      beginScope: {// 2: \"attr\"\n      },\n      end: /$/\n    }]\n  };\n  return {\n    name: \"Wren\",\n    keywords: {\n      keyword: KEYWORDS,\n      \"variable.language\": LANGUAGE_VARS,\n      literal: LITERALS\n    },\n    contains: [ATTRIBUTE, NUMBER, STRING, TRIPLE_STRING, COMMENT_DOCS, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, CLASS_REFERENCE, CLASS_DEFINITION, SETTER, FUNCTION_DEFINITION, FUNCTION, OPERATOR, FIELD, PROPERTY, VARIABLE]\n  };\n}\n\nmodule.exports = wren;","map":{"version":3,"sources":["/home/mateus/Documents/Projects/alura-challenge/node_modules/highlight.js/lib/languages/wren.js"],"names":["source","re","lookahead","concat","args","joined","map","x","join","stripOptionsFromArgs","opts","length","constructor","Object","splice","either","capture","wren","hljs","IDENT_RE","KEYWORDS","LITERALS","LANGUAGE_VARS","CORE_CLASSES","OPERATORS","FUNCTION","relevance","match","className","FUNCTION_DEFINITION","starts","contains","begin","end","scope","CLASS_DEFINITION","variants","keywords","OPERATOR","TRIPLE_STRING","PROPERTY","excludeBegin","FIELD","CLASS_REFERENCE","_","NUMBER","C_NUMBER_MODE","SETTER","COMMENT_DOCS","COMMENT","SUBST","STRING","push","ALL_KWS","VARIABLE","ATTRIBUTE","beginScope","literal","name","keyword","C_LINE_COMMENT_MODE","C_BLOCK_COMMENT_MODE","module","exports"],"mappings":"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","sourcesContent":["/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = '(' +\n    (opts.capture ? \"\" : \"?:\") +\n    args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\n/*\nLanguage: Wren\nDescription: Think Smalltalk in a Lua-sized package with a dash of Erlang and wrapped up in a familiar, modern syntax.\nCategory: scripting\nAuthor: @joshgoebel\nMaintainer: @joshgoebel\nWebsite: https://wren.io/\n*/\n\n/** @type LanguageFn */\nfunction wren(hljs) {\n  const IDENT_RE = /[a-zA-Z]\\w*/;\n  const KEYWORDS = [\n    \"as\",\n    \"break\",\n    \"class\",\n    \"construct\",\n    \"continue\",\n    \"else\",\n    \"for\",\n    \"foreign\",\n    \"if\",\n    \"import\",\n    \"in\",\n    \"is\",\n    \"return\",\n    \"static\",\n    \"var\",\n    \"while\"\n  ];\n  const LITERALS = [\n    \"true\",\n    \"false\",\n    \"null\"\n  ];\n  const LANGUAGE_VARS = [\n    \"this\",\n    \"super\"\n  ];\n  const CORE_CLASSES = [\n    \"Bool\",\n    \"Class\",\n    \"Fiber\",\n    \"Fn\",\n    \"List\",\n    \"Map\",\n    \"Null\",\n    \"Num\",\n    \"Object\",\n    \"Range\",\n    \"Sequence\",\n    \"String\",\n    \"System\"\n  ];\n  const OPERATORS = [\n    \"-\",\n    \"~\",\n    /\\*/,\n    \"%\",\n    /\\.\\.\\./,\n    /\\.\\./,\n    /\\+/,\n    \"<<\", \">>\",\n    \">=\", \"<=\",\n    \"<\", \">\",\n    /\\^/,\n    /!=/,\n    /!/,\n    /\\bis\\b/,\n    \"==\",\n    \"&&\",\n    \"&\",\n    /\\|\\|/,\n    /\\|/,\n    /\\?:/,\n    \"=\"\n  ];\n  const FUNCTION = {\n    relevance: 0,\n    match: concat(/\\b(?!(if|while|for|else|super)\\b)/, IDENT_RE, /(?=\\s*[({])/),\n    className: \"title.function\"\n  };\n  const FUNCTION_DEFINITION = {\n    match: concat(\n      either(\n        concat(/\\b(?!(if|while|for|else|super)\\b)/, IDENT_RE),\n        either(...OPERATORS)\n      ),\n      /(?=\\s*\\([^)]+\\)\\s*\\{)/),\n    className: \"title.function\",\n    starts: {\n      contains: [\n        {\n          begin: /\\(/,\n          end: /\\)/,\n          contains: [\n            {\n              relevance: 0,\n              scope: \"params\",\n              match: IDENT_RE\n            }\n          ]\n        }\n      ]\n    }\n  };\n  const CLASS_DEFINITION = {\n    variants: [\n      {\n        match: [\n          /class\\s+/,\n          IDENT_RE,\n          /\\s+is\\s+/,\n          IDENT_RE\n        ]\n      },\n      {\n        match: [\n          /class\\s+/,\n          IDENT_RE\n        ]\n      }\n    ],\n    scope: {\n      2: \"title.class\",\n      4: \"title.class.inherited\"\n    },\n    keywords: KEYWORDS\n  };\n\n  const OPERATOR = {\n    relevance: 0,\n    match: either(...OPERATORS),\n    className: \"operator\"\n  };\n\n  const TRIPLE_STRING = {\n    className: \"string\",\n    begin: /\"\"\"/,\n    end: /\"\"\"/\n  };\n\n  const PROPERTY = {\n    className: \"property\",\n    begin: concat(/\\./, lookahead(IDENT_RE)),\n    end: IDENT_RE,\n    excludeBegin: true,\n    relevance: 0\n  };\n\n  const FIELD = {\n    relevance: 0,\n    match: concat(/\\b_/, IDENT_RE),\n    scope: \"variable\"\n  };\n\n  // CamelCase\n  const CLASS_REFERENCE = {\n    relevance: 0,\n    match: /[A-Z]+[a-z]+([A-Z]+[a-z]+)*/,\n    scope: \"title.class\",\n    keywords: {\n      _: CORE_CLASSES\n    }\n  };\n\n  // TODO: add custom number modes\n  const NUMBER = hljs.C_NUMBER_MODE;\n\n  const SETTER = {\n    match: [\n      IDENT_RE, /\\s*/,\n      /=/, /\\s*/,\n      /\\(/, IDENT_RE, /\\)\\s*\\{/\n    ],\n    scope: {\n      1: \"title.function\",\n      3: \"operator\",\n      6: \"params\"\n    }\n  };\n\n  const COMMENT_DOCS = hljs.COMMENT(\n    /\\/\\*\\*/,\n    /\\*\\//,\n    {\n      contains: [\n        {\n          match: /@[a-z]+/,\n          scope: \"doctag\"\n        },\n        \"self\"\n      ]\n    }\n  );\n  const SUBST = {\n    scope: \"subst\",\n    begin: /%\\(/,\n    end: /\\)/,\n    contains: [\n      NUMBER,\n      CLASS_REFERENCE,\n      FUNCTION,\n      FIELD,\n      OPERATOR\n    ]\n  };\n  const STRING = {\n    scope: \"string\",\n    begin: /\"/,\n    end: /\"/,\n    contains: [\n      SUBST,\n      {\n        scope: \"char.escape\",\n        variants: [\n          { match: /\\\\\\\\|\\\\[\"0%abefnrtv]/ },\n          { match: /\\\\x[0-9A-F]{2}/ },\n          { match: /\\\\u[0-9A-F]{4}/ },\n          { match: /\\\\U[0-9A-F]{8}/ }\n        ]\n      }\n    ]\n  };\n  SUBST.contains.push(STRING);\n\n  const ALL_KWS = [...KEYWORDS, ...LANGUAGE_VARS, ...LITERALS];\n  const VARIABLE = {\n    relevance: 0,\n    match: concat(\n      \"\\\\b(?!\",\n      ALL_KWS.join(\"|\"),\n      \"\\\\b)\",\n      /[a-zA-Z_]\\w*(?:[?!]|\\b)/\n    ),\n    className: \"variable\"\n  };\n\n  // TODO: reconsider this in the future\n  const ATTRIBUTE = {\n    // scope: \"meta\",\n    scope: \"comment\",\n    variants: [\n      {\n        begin: [/#!?/, /[A-Za-z_]+(?=\\()/],\n        beginScope: {\n          // 2: \"attr\"\n        },\n        keywords: {\n          literal: LITERALS\n        },\n        contains: [\n          // NUMBER,\n          // VARIABLE\n        ],\n        end: /\\)/\n      },\n      {\n        begin: [/#!?/, /[A-Za-z_]+/],\n        beginScope: {\n          // 2: \"attr\"\n        },\n        end: /$/\n      }\n    ]\n  };\n\n  return {\n    name: \"Wren\",\n    keywords: {\n      keyword: KEYWORDS,\n      \"variable.language\": LANGUAGE_VARS,\n      literal: LITERALS\n    },\n    contains: [\n      ATTRIBUTE,\n      NUMBER,\n      STRING,\n      TRIPLE_STRING,\n      COMMENT_DOCS,\n      hljs.C_LINE_COMMENT_MODE,\n      hljs.C_BLOCK_COMMENT_MODE,\n      CLASS_REFERENCE,\n      CLASS_DEFINITION,\n      SETTER,\n      FUNCTION_DEFINITION,\n      FUNCTION,\n      OPERATOR,\n      FIELD,\n      PROPERTY,\n      VARIABLE\n    ]\n  };\n}\n\nmodule.exports = wren;\n"]},"metadata":{},"sourceType":"script"}